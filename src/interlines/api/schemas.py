"""
API Data Contracts (Schemas) for InterLines.

Milestone
---------
M6 | Interface & Deployment
Step 6.1 | API interpret/brief/health

This module defines the Pydantic models used for the HTTP API input and output.
It serves as the Single Source of Truth (SSOT) for the OpenAPI (Swagger)
documentation generated by FastAPI.

Design Pattern: Async Job Queue
-------------------------------
Since the InterLines pipeline involves multiple LLM calls (Parser -> Planner ->
Explainer -> Editor...), processing a single request can take 10s-60s.
To avoid HTTP timeouts, the API adopts an asynchronous job pattern:

1. **Submission**: Client POSTs an `InterpretRequest`. Server returns a `JobInfo`
   (Accepted, 202) immediately.
2. **Polling**: Client polls `GET /jobs/{job_id}` to check `JobStatus`.
3. **Retrieval**: Once status is 'completed', the result contains the
   `InterpretResponse` (brief, cards, etc.).

Schema Layers
-------------
- **Requests**: What the user sends (e.g., raw text, config flags).
- **Envelopes**: Standard wrappers for jobs and health checks.
- **Payloads**: The actual domain objects (PublicBrief, etc.) returned on success.
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum

from pydantic import BaseModel, Field

from interlines.core.contracts.public_brief import BriefSection

# --------------------------------------------------------------------------- #
# Shared Enums
# --------------------------------------------------------------------------- #


class JobStatus(str, Enum):
    """
    Lifecycle states of an asynchronous analysis job.

    States
    ------
    - PENDING: Request received, waiting in queue (memory/redis).
    - PROCESSING: Pipeline is currently executing agents.
    - COMPLETED: Pipeline finished successfully; results available.
    - FAILED: Pipeline crashed or rejected the input.
    """

    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


# --------------------------------------------------------------------------- #
# Request Models (Inputs)
# --------------------------------------------------------------------------- #


class InterpretRequest(BaseModel):
    """
    Payload for `POST /interpret`.

    The user provides raw text (or eventually a URL/File ID) and optional
    configuration flags to steer the Planner.
    """

    text: str = Field(
        ...,
        min_length=10,
        max_length=100_000,
        description="The raw source text to interpret (10-100k chars).",
        examples=["The concept of 'Distributed Confidence' in AI safety suggests..."],
    )

    enable_history: bool = Field(
        default=False,
        description=(
            "Hint to the planner: should we look for a timeline? "
            "If True, the History Agent is more likely to be invoked."
        ),
    )

    use_llm_planner: bool = Field(
        default=True,
        description=(
            "If True, use the LLM-backed PlannerAgent for semantic routing. "
            "If False, use the deterministic rule-based planner (legacy)."
        ),
    )


# --------------------------------------------------------------------------- #
# Response Models (Outputs)
# --------------------------------------------------------------------------- #


class HealthResponse(BaseModel):
    """Payload for `GET /health`."""

    status: str = Field(default="ok", description="Service health status.")
    version: str = Field(..., description="Semantic version of the backend.")
    environment: str = Field(default="production", description="dev/staging/prod")


class PublicBriefPayload(BaseModel):
    """
    A flatten, API-friendly representation of the generated brief.

    This mirrors `interlines.pipelines.public_translation.PublicBriefPayload`
    but as a strict Pydantic model for OpenAPI documentation.
    """

    title: str = Field(description="Generated title of the brief.")
    summary: str = Field(description="Executive summary paragraph.")
    sections: list[BriefSection] = Field(
        default_factory=list,
        description="Structured sections with headings and bullets.",
    )


class InterpretResult(BaseModel):
    """
    The final output produced by a completed pipeline job.

    Currently, this focuses on the public brief. In future steps, it may
    include the full graph of artifacts (Explanations, TimelineEvents)
    if the frontend needs raw data.
    """

    brief: PublicBriefPayload
    # Future extension:
    # artifacts: dict[str, list[Any]] = ...


class JobInfo(BaseModel):
    """
    Metadata for a background task.

    Returned by `POST /interpret` (submission) and `GET /jobs/{id}` (polling).
    If `status` is COMPLETED, the `result` field will be populated.
    """

    job_id: str = Field(..., description="Unique UUID for tracking the request.")
    status: JobStatus = Field(..., description="Current processing state.")
    created_at: datetime = Field(..., description="UTC timestamp of submission.")

    error: str | None = Field(
        default=None,
        description="Error message if status is FAILED.",
    )

    result: InterpretResult | None = Field(
        default=None,
        description=("The analysis output. " "Only present when status is COMPLETED."),
    )


__all__ = [
    "JobStatus",
    "InterpretRequest",
    "HealthResponse",
    "JobInfo",
    "InterpretResult",
    "PublicBriefPayload",
]
